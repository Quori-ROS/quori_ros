{"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle","symbols":{"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-destruct":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-destruct","display_name":"destruct","comment":null,"template_args":null,"params":[],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"private","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.NodeHandle":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.NodeHandle","display_name":"NodeHandle","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Parent constructor"}]},{"type":"paragraph","children":[{"type":"text","text":" This version of the constructor takes a \"parent\" NodeHandle."},{"type":"text","text":" If the passed \"ns\" is relative (does not start with a slash), it is equivalent to calling:"},{"type":"text","text":"     "}]},{"type":"verbatimcommand","parts":["     NodeHandle child(parent.getNamespace() + \"/\" + ns, remappings);"]},{"type":"paragraph","children":[{"type":"text","text":" If the passed \"ns\" is absolute (does start with a slash), it is equivalent to calling:"},{"type":"text","text":"     "}]},{"type":"verbatimcommand","parts":["     NodeHandle child(ns, remappings);"]},{"type":"paragraph","children":[{"type":"text","text":" This version also lets you pass in name remappings that are specific to this NodeHandle"}]},{"type":"paragraph","children":[{"type":"text","text":" When a NodeHandle is copied, it inherits the namespace of the NodeHandle being copied, "},{"type":"text","text":" and increments the reference count of the global node state"},{"type":"text","text":" by 1."},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException if the namespace is not a valid graph resource name"}]}],"template_args":null,"params":[{"name":"parent","ty":{"kind":"lvaluereference","display_name":"const ros::NodeHandle &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"const ros::NodeHandle","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle","const_qualified":true,"pointee":null,"elaborated":null},"elaborated":null}},{"name":"ns","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}},{"name":"remappings","ty":{"kind":"lvaluereference","display_name":"const ros::M_string &","name":null,"const_qualified":false,"pointee":{"kind":"typedef","display_name":"const ros::M_string","name":null,"const_qualified":true,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":true,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getUnresolvedNamespace":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getUnresolvedNamespace","display_name":"getUnresolvedNamespace","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Returns the namespace associated with this NodeHandle as"},{"type":"text","text":" it was passed in (before it was resolved)"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.unresolved_namespace_":{"type":"variable","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.unresolved_namespace_","display_name":"unresolved_namespace_","ty":{"kind":"elaborated","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"comment":null,"visibility":"default","accessibility":"private"},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandleBackingCollection":{"type":"class","is_struct":false,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandleBackingCollection","display_name":"NodeHandleBackingCollection","comment":null,"template_args":null,"children":[]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-advertiseService":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-advertiseService","display_name":"advertiseService","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Advertise a service, with full range of AdvertiseServiceOptions"}]},{"type":"paragraph","children":[{"type":"text","text":" This call connects to the master to publicize that the node will be"},{"type":"text","text":" offering an RPC service with the given name."}]},{"type":"paragraph","children":[{"type":"text","text":" This version of advertiseService allows the full set of options, exposed through the AdvertiseServiceOptions class"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"ops","direction":null,"children":[{"type":"text","text":" Advertise options"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service."},{"type":"text","text":" On failure, an empty ServiceServer which can be checked with:"}]},{"type":"verbatimcommand","parts":["AdvertiseServiceOptions ops;","...","ros::NodeHandle nodeHandle;","ros::ServiceServer service = nodeHandle.advertiseService(ops);","if (service)  // Enter if advertised service is valid","{","...","}"]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"ops","ty":{"kind":"lvaluereference","display_name":"ros::AdvertiseServiceOptions &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::AdvertiseServiceOptions","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"record","display_name":"ros::ServiceServer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-ServiceServer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle":{"type":"class","is_struct":false,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle","display_name":"NodeHandle","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" roscpp's interface for creating subscribers, publishers, etc."}]},{"type":"paragraph","children":[{"type":"text","text":" This class is used for writing nodes.  It provides a RAII interface"},{"type":"text","text":" to this process' node, in that when the first NodeHandle is"},{"type":"text","text":" created, it instantiates everything necessary for this node, and"},{"type":"text","text":" when the last NodeHandle goes out of scope it shuts down the node."}]},{"type":"paragraph","children":[{"type":"text","text":" NodeHandle uses reference counting internally, and copying a"},{"type":"text","text":" NodeHandle is very lightweight."}]},{"type":"paragraph","children":[{"type":"text","text":" You must call one of the ros::init functions prior to instantiating"},{"type":"text","text":" this class."}]},{"type":"paragraph","children":[{"type":"text","text":" The most widely used methods are:"},{"type":"text","text":"   - Setup:"},{"type":"text","text":"    - ros::init()"},{"type":"text","text":"   - Publish / subscribe messaging:"},{"type":"text","text":"    - advertise()"},{"type":"text","text":"    - subscribe()"},{"type":"text","text":"   - RPC services:"},{"type":"text","text":"    - advertiseService()"},{"type":"text","text":"    - serviceClient()"},{"type":"text","text":"    - ros::service::call()"},{"type":"text","text":"   - Parameters:"},{"type":"text","text":"    - getParam()"},{"type":"text","text":"    - setParam()"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-destruct","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-serviceClient","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-advertiseService","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-initRemappings","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createWallTimer","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-setParam","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-setCallbackQueue","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.namespace_","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.unresolved_remappings_","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createSteadyTimer","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.subscribe","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-operator=","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-hasParam","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.s-no_validate","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createWallTimer","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.serviceClient","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getUnresolvedNamespace","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-deleteParam","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-advertise","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.advertise","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getNamespace","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParamCached","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-construct","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-ok","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.param","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.NodeHandle","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.unresolved_namespace_","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.advertiseService","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createSteadyTimer","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParamNames","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-searchParam","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.remappings_","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-subscribe","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createTimer","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-shutdown","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.callback_queue_","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.collection_","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.U126NodeHandle","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-remapName","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-resolveName","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.ok_","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParam","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createTimer","root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getCallbackQueue"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getCallbackQueue":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getCallbackQueue","display_name":"getCallbackQueue","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Returns the callback queue associated with this"},{"type":"text","text":" NodeHandle.  If none has been explicitly set, returns the global"},{"type":"text","text":" queue."}]}],"template_args":null,"params":[],"ret_ty":{"kind":"pointer","display_name":"ros::CallbackQueueInterface *","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::CallbackQueueInterface","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-CallbackQueueInterface","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-setCallbackQueue":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-setCallbackQueue","display_name":"setCallbackQueue","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Set the default callback queue to be used by this NodeHandle."}]},{"type":"paragraph","children":[{"type":"text","text":" Setting this will cause any callbacks from"},{"type":"text","text":" advertisements/subscriptions/services/etc. to happen through the"},{"type":"text","text":" use of the specified queue.  NULL (the default) causes the global"},{"type":"text","text":" queue (serviced by ros::spin() and ros::spinOnce()) to be used."}]}],"template_args":null,"params":[{"name":"queue","ty":{"kind":"pointer","display_name":"ros::CallbackQueueInterface *","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::CallbackQueueInterface","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-CallbackQueueInterface","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions","display_name":"SteadyTimerOptions","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Encapsulates all options available for starting a timer"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions.period","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions.oneshot","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions.callback","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions.SteadyTimerOptions","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions.callback_queue","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions.tracked_object","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions.autostart"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createSteadyTimer":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createSteadyTimer","display_name":"createSteadyTimer","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a timer which will call a callback at the specified rate, using wall time to determine"},{"type":"text","text":" when to call the callback instead of ROS time.  This variant allows"},{"type":"text","text":" the full range of TimerOptions."}]},{"type":"paragraph","children":[{"type":"text","text":" When the Timer (and all copies of it) returned goes out of scope, the timer will automatically"},{"type":"text","text":" be stopped, and the callback will no longer be called."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"ops","direction":null,"children":[{"type":"text","text":" The options to use when creating the timer"}]}],"template_args":null,"params":[{"name":"ops","ty":{"kind":"lvaluereference","display_name":"ros::SteadyTimerOptions &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::SteadyTimerOptions","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-SteadyTimerOptions","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"record","display_name":"ros::SteadyTimer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-SteadyTimer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions","display_name":"AdvertiseOptions","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Encapsulates all options available for creating a Publisher"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.topic","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.connect_cb","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.tracked_object","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.init","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.datatype","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.message_definition","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.latch","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.callback_queue","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.has_header","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.create","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.disconnect_cb","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.queue_size","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.md5sum","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions.AdvertiseOptions"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.ok_":{"type":"variable","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.ok_","display_name":"ok_","ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"comment":null,"visibility":"default","accessibility":"private"},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.callback_queue_":{"type":"variable","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.callback_queue_","display_name":"callback_queue_","ty":{"kind":"pointer","display_name":"ros::CallbackQueueInterface *","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::CallbackQueueInterface","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-CallbackQueueInterface","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null},"comment":null,"visibility":"default","accessibility":"private"},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createWallTimer":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createWallTimer","display_name":"createWallTimer","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a timer which will call a callback at the specified rate, using wall time to determine"},{"type":"text","text":" when to call the callback instead of ROS time.  This variant takes"},{"type":"text","text":" a class member function, and a shared pointer to the object to call the method on."}]},{"type":"paragraph","children":[{"type":"text","text":" When the Timer (and all copies of it) returned goes out of scope, the timer will automatically"},{"type":"text","text":" be stopped, and the callback will no longer be called."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"period","direction":null,"children":[{"type":"text","text":" The period at which to call the callback"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"callback","direction":null,"children":[{"type":"text","text":" The method to call"},{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"obj","direction":null,"children":[{"type":"text","text":" The object to call the method on.  Since this is a shared pointer, the object will"},{"type":"text","text":" automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of"},{"type":"text","text":" scope the callback will no longer be called (and therefore will not crash)."},{"type":"text","text":" "}]},{"type":"paramcommand","index":3,"parameter":"oneshot","direction":null,"children":[{"type":"text","text":" If true, this timer will only fire once"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::WallTimer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-WallTimer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.remappings_":{"type":"variable","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.remappings_","display_name":"remappings_","ty":{"kind":"typedef","display_name":"ros::M_string","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"comment":null,"visibility":"default","accessibility":"private"},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.advertiseService":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.advertiseService","display_name":"advertiseService","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Advertise a service, version for arbitrary boost::function object using ros::ServiceEvent as the callback parameter type"}]},{"type":"paragraph","children":[{"type":"text","text":" Note that the template parameter S is the full event type, e.g. ros::ServiceEvent"},{"type":"text","text":"<Req"},{"type":"text","text":", Res>"}]},{"type":"paragraph","children":[{"type":"text","text":" This call connects to the master to publicize that the node will be"},{"type":"text","text":" offering an RPC service with the given name."}]},{"type":"paragraph","children":[{"type":"text","text":" This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything"},{"type":"text","text":" else boost::function supports)."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"service","direction":null,"children":[{"type":"text","text":" Service name to advertise on"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"callback","direction":null,"children":[{"type":"text","text":" Callback to call when the service is called"},{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"tracked_object","direction":null,"children":[{"type":"text","text":" A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,"},{"type":"text","text":" and if the reference count goes to 0 the subscriber callbacks will not get called."},{"type":"text","text":" Note that setting this will cause a new reference to be added to the object before the"},{"type":"text","text":" callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore"},{"type":"text","text":" thread) that the callback is invoked from."},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service."},{"type":"text","text":" On failure, an empty ServiceServer which can be checked with:"}]},{"type":"verbatimcommand","parts":["bool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)","{","  return true;","}","ros::NodeHandle nodeHandle;","Foo foo_object;","ros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);","if (service)  // Enter if advertised service is valid","{","...","}"]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::ServiceServer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-ServiceServer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.s-no_validate":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.s-no_validate","display_name":"no_validate","comment":null,"template_args":null,"children":[]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-resolveName":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-resolveName","display_name":"resolveName","comment":null,"template_args":null,"params":[{"name":"name","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}},{"name":"remap","ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},{"name":"","ty":{"kind":"record","display_name":"ros::NodeHandle::no_validate","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.s-no_validate","const_qualified":false,"pointee":null,"elaborated":null}}],"ret_ty":{"kind":"elaborated","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"visibility":"default","accessibility":"private","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParamNames":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParamNames","display_name":"getParamNames","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Get the keys for all the parameters in the parameter server."},{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"keys","direction":null,"children":[{"type":"text","text":" The keys retrieved."},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" true if the query succeeded, false otherwise."}]}],"template_args":null,"params":[{"name":"keys","ty":{"kind":"lvaluereference","display_name":"std::vector<std::string> &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"std::vector<std::string>","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"unexposed","display_name":"vector<std::string>","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.advertise":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.advertise","display_name":"advertise","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Advertise a topic, with most of the available options, including subscriber status callbacks"}]},{"type":"paragraph","children":[{"type":"text","text":" This call connects to the master to publicize that the node will be"},{"type":"text","text":" publishing messages on the given topic.  This method returns a Publisher that allows you to"},{"type":"text","text":" publish a message on this topic."}]},{"type":"paragraph","children":[{"type":"text","text":" This version of advertise allows you to pass functions to be called when new subscribers connect and"},{"type":"text","text":" disconnect.  With bare functions it can be used like so:"},{"type":"text","text":"     "}]},{"type":"verbatimcommand","parts":["     void connectCallback(const ros::SingleSubscriberPublisher& pub)","     {","     // Do something","     }","\n     handle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)connectCallback);\n     \\endverbatim\n     *\n     * With class member functions it can be used with boost::bind:\n     \\verbatim\n     void MyClass::connectCallback(const ros::SingleSubscriberPublisher& pub)\n     {\n     // Do something\n     }\n\n     MyClass my_class;\n     ros::Publisher pub = handle.advertise<std_msgs::Empty>(\"my_topic\", 1, \n                                                            boost::bind(&MyClass::connectCallback, my_class, _1));\n     \\endverbatim\n     *\n   *\n   * \\param topic Topic to advertise on\n   *\n   * \\param queue_size Maximum number of outgoing messages to be queued for delivery to subscribers\n   *\n   * \\param connect_cb Function to call when a subscriber connects\n   *\n   * \\param disconnect_cb (optional) Function to call when a subscriber disconnects\n     *\n   * \\param tracked_object (optional) A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param latch (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::publisher pub = nodeHandle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)callback);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template <class M>\n  Publisher advertise(const std::string& topic, uint32_t queue_size,\n                            const SubscriberStatusCallback& connect_cb,\n                            const SubscriberStatusCallback& disconnect_cb = SubscriberStatusCallback(),\n                            const VoidConstPtr& tracked_object = VoidConstPtr(),\n                            bool latch = false)\n  {\n    AdvertiseOptions ops;\n    ops.template init<M>(topic, queue_size, connect_cb, disconnect_cb);\n    ops.tracked_object = tracked_object;\n    ops.latch = latch;\n    return advertise(ops);\n  }\n\n  /**\n   * \\brief Advertise a topic, with full range of AdvertiseOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * publishing messages on the given topic.  This method returns a Publisher that allows you to\n   * publish a message on this topic.\n   *\n   * This is an advanced version advertise() that exposes all options (through the AdvertiseOptions structure)\n   *\n   * \\param ops Advertise options to use\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::AdvertiseOptions ops;\n...\nros::publisher pub = nodeHandle.advertise(ops);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   *\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  Publisher advertise(AdvertiseOptions& ops);\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of subscribe()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /// and the const version\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(M), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(const boost::shared_ptr<M const>&), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (const boost::shared_ptr<M const>&)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] the message type\n   * \\param C [template] the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&)\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class C>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (C)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<C>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version with full range of SubscribeOptions\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows the full range of options, exposed through the SubscribeOptions class\n   *\n   * \\param ops Subscribe options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nSubscribeOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(ops);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  Subscriber subscribe(SubscribeOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of advertiseService()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj, _1, _2));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty::Request, std_srvs::Empty::Response>& event)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj, _1));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj.get(), _1, _2));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj.get(), _1));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(MReq&, MRes&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(ServiceEvent<MReq, MRes>&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object using ros::ServiceEvent as the callback parameter type\n   *\n   * Note that the template parameter S is the full event type, e.g. ros::ServiceEvent<Req, Res>\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class S>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(S&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<S>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, with full range of AdvertiseServiceOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows the full set of options, exposed through the AdvertiseServiceOptions class\n   *\n   * \\param ops Advertise options\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nAdvertiseServiceOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::ServiceServer service = nodeHandle.advertiseService(ops);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceServer advertiseService(AdvertiseServiceOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of serviceClient()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /** @brief Create a client for a service, version templated on two message types\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<MReq, MRes>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version templated on service type\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class Service>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<Service>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version with full range of ServiceClientOptions\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param ops The options for this service client\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceClient serviceClient(ServiceClientOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param r The rate at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class Handler, class Obj>\n  Timer createTimer(Rate r, Handler h, Obj o, bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(r.expectedCycleTime(), h, o, oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&) const, T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), const boost::shared_ptr<T>& obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    TimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  Timer createTimer(Duration period, const TimerCallback& callback, bool oneshot = false,\n                    bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  Timer createTimer(TimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createWallTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), T* obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    return createWallTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), \n                            const boost::shared_ptr<T>& obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    WallTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createWallTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  WallTimer createWallTimer(WallDuration period, const WallTimerCallback& callback, \n                            bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  WallTimer createWallTimer(WallTimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createSteadyTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&), T* obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    return createSteadyTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&),\n                                const boost::shared_ptr<T>& obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    SteadyTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createSteadyTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  SteadyTimer createSteadyTimer(WallDuration period, const SteadyTimerCallback& callback,\n                                bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  SteadyTimer createSteadyTimer(SteadyTimerOptions& ops) const;\n\n  /** \\brief Set an arbitrary XML/RPC value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param v The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const XmlRpc::XmlRpcValue& v) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::string& s) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const char* s) const;\n  /** \\brief Set a double value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param d The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, double d) const;\n  /** \\brief Set an integer value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param i The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, int i) const;\n  /** \\brief Set a boolean value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param b The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, bool b) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<std::string>& vec) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<double>& vec) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<float>& vec) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<int>& vec) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<bool>& vec) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, std::string>& map) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, double>& map) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, float>& map) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, int>& map) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a string vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get an int vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a boolean vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a double map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a float map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get an int map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a boolean map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server, with local caching\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a std::string vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get a int vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a bool vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string->std::string map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a string->double map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a string->float map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get a string->int map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a string->bool map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Check whether a parameter exists on the parameter server.\n   *\n   * \\param key The key to check.\n   *\n   * \\return true if the parameter exists, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool hasParam(const std::string& key) const;\n  /** \\brief Search up the tree for a parameter with a given key\n   *\n   * This function parameter server's searchParam feature to search up the tree for\n   * a parameter.  For example, if the parameter server has a parameter [/a/b]\n   * and you're in the namespace [/a/c/d], searching for the parameter \"b\" will\n   * yield [/a/b].  If [/a/c/d/b] existed, that parameter would be returned instead.\n   *\n   * \\param key the parameter to search for\n   * \\param [out] result the found value (if any)\n   *\n   * \\return true if the parameter was found, false otherwise.\n   */\n  bool searchParam(const std::string& key, std::string& result) const;\n  /** \\brief Delete a parameter from the parameter server.\n   *\n   * \\param key The key to delete.\n   *\n   * \\return true if the deletion succeeded, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool deleteParam(const std::string& key) const;\n\n  /** \\brief Get the keys for all the parameters in the parameter server.\n   * \\param keys The keys retrieved.\n   * \\return true if the query succeeded, false otherwise.\n   */\n  bool getParamNames(std::vector<std::string>& keys) const;\n\n  /** \\brief Assign value from parameter server, with default.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server, storing the result in param_val.  If the value\n   * cannot be retrieved from the server, default_val is used instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   * \\param[out] param_val Storage for the retrieved value.\n   * \\param default_val Value to use if the server doesn't contain this\n   * parameter.\n   * \\return true if the parameter was retrieved from the server, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<typename T>\n  bool param(const std::string& param_name, T& param_val, const T& default_val) const\n  {\n    if (hasParam(param_name))\n    {\n      if (getParam(param_name, param_val))\n      {\n        return true;\n      }\n    }\n\n    param_val = default_val;\n    return false;\n  }\n\n  /**\n   * \\brief Return value from parameter server, or default if unavailable.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server. If the parameter cannot be retrieved, \\c default_val\n   * is returned instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   *\n   * \\param default_val Value to return if the server doesn't contain this\n   * parameter.\n   *\n   * \\return The parameter value retrieved from the parameter server, or\n   * \\c default_val if unavailable.\n   *\n   * \\throws InvalidNameException If the parameter key begins with a tilde,\n   * or is an otherwise invalid graph resource name.\n   */\n  template<typename T>\n  T param(const std::string& param_name, const T& default_val) const\n  {\n      T param_val;\n      param(param_name, param_val, default_val);\n      return param_val;\n  }\n\n  /**\n   * \\brief Shutdown every handle created through this NodeHandle.\n   *\n   * This method will unadvertise every topic and service advertisement,\n   * and unsubscribe every subscription created through this NodeHandle.\n   */\n  void shutdown();\n\n  /** \\brief Check whether it's time to exit.\n   *\n   * This method checks to see if both ros::ok() is true and shutdown() has not been called on this NodeHandle, to see whether it's yet time\n   * to exit.  ok() is false once either ros::shutdown() or NodeHandle::shutdown() have been called\n   *\n   * \\return true if we're still OK, false if it's time to exit\n   */\n  bool ok() const;\n\nprivate:\n  struct no_validate { };\n  // this is pretty awful, but required to preserve public interface (and make minimum possible changes)\n  std::string resolveName(const std::string& name, bool remap, no_validate) const;\n\n  void construct(const std::string& ns, bool validate_name);\n  void destruct();\n\n  void initRemappings(const M_string& remappings);\n\n  std::string remapName(const std::string& name) const;\n\n  std::string namespace_;\n  std::string unresolved_namespace_;\n  M_string remappings_;\n  M_string unresolved_remappings_;\n\n  CallbackQueueInterface* callback_queue_;\n\n  NodeHandleBackingCollection* collection_;\n\n  bool ok_;\n};\n\n}\n\n#endif // ROSCPP_NODE_HANDLE_H\n","     handle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)connectCallback);"]},{"type":"paragraph","children":[{"type":"text","text":" With class member functions it can be used with boost::bind:"},{"type":"text","text":"     "}]},{"type":"verbatimcommand","parts":["     void MyClass::connectCallback(const ros::SingleSubscriberPublisher& pub)","     {","     // Do something","     }","\n     MyClass my_class;\n     ros::Publisher pub = handle.advertise<std_msgs::Empty>(\"my_topic\", 1, \n                                                            boost::bind(&MyClass::connectCallback, my_class, _1));\n     \\endverbatim\n     *\n   *\n   * \\param topic Topic to advertise on\n   *\n   * \\param queue_size Maximum number of outgoing messages to be queued for delivery to subscribers\n   *\n   * \\param connect_cb Function to call when a subscriber connects\n   *\n   * \\param disconnect_cb (optional) Function to call when a subscriber disconnects\n     *\n   * \\param tracked_object (optional) A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param latch (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::publisher pub = nodeHandle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)callback);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template <class M>\n  Publisher advertise(const std::string& topic, uint32_t queue_size,\n                            const SubscriberStatusCallback& connect_cb,\n                            const SubscriberStatusCallback& disconnect_cb = SubscriberStatusCallback(),\n                            const VoidConstPtr& tracked_object = VoidConstPtr(),\n                            bool latch = false)\n  {\n    AdvertiseOptions ops;\n    ops.template init<M>(topic, queue_size, connect_cb, disconnect_cb);\n    ops.tracked_object = tracked_object;\n    ops.latch = latch;\n    return advertise(ops);\n  }\n\n  /**\n   * \\brief Advertise a topic, with full range of AdvertiseOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * publishing messages on the given topic.  This method returns a Publisher that allows you to\n   * publish a message on this topic.\n   *\n   * This is an advanced version advertise() that exposes all options (through the AdvertiseOptions structure)\n   *\n   * \\param ops Advertise options to use\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::AdvertiseOptions ops;\n...\nros::publisher pub = nodeHandle.advertise(ops);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   *\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  Publisher advertise(AdvertiseOptions& ops);\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of subscribe()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /// and the const version\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(M), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(const boost::shared_ptr<M const>&), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (const boost::shared_ptr<M const>&)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] the message type\n   * \\param C [template] the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&)\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class C>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (C)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<C>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version with full range of SubscribeOptions\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows the full range of options, exposed through the SubscribeOptions class\n   *\n   * \\param ops Subscribe options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nSubscribeOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(ops);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  Subscriber subscribe(SubscribeOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of advertiseService()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj, _1, _2));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty::Request, std_srvs::Empty::Response>& event)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj, _1));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj.get(), _1, _2));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj.get(), _1));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(MReq&, MRes&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(ServiceEvent<MReq, MRes>&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object using ros::ServiceEvent as the callback parameter type\n   *\n   * Note that the template parameter S is the full event type, e.g. ros::ServiceEvent<Req, Res>\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class S>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(S&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<S>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, with full range of AdvertiseServiceOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows the full set of options, exposed through the AdvertiseServiceOptions class\n   *\n   * \\param ops Advertise options\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nAdvertiseServiceOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::ServiceServer service = nodeHandle.advertiseService(ops);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceServer advertiseService(AdvertiseServiceOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of serviceClient()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /** @brief Create a client for a service, version templated on two message types\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<MReq, MRes>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version templated on service type\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class Service>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<Service>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version with full range of ServiceClientOptions\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param ops The options for this service client\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceClient serviceClient(ServiceClientOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param r The rate at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class Handler, class Obj>\n  Timer createTimer(Rate r, Handler h, Obj o, bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(r.expectedCycleTime(), h, o, oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&) const, T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), const boost::shared_ptr<T>& obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    TimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  Timer createTimer(Duration period, const TimerCallback& callback, bool oneshot = false,\n                    bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  Timer createTimer(TimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createWallTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), T* obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    return createWallTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), \n                            const boost::shared_ptr<T>& obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    WallTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createWallTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  WallTimer createWallTimer(WallDuration period, const WallTimerCallback& callback, \n                            bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  WallTimer createWallTimer(WallTimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createSteadyTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&), T* obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    return createSteadyTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&),\n                                const boost::shared_ptr<T>& obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    SteadyTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createSteadyTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  SteadyTimer createSteadyTimer(WallDuration period, const SteadyTimerCallback& callback,\n                                bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  SteadyTimer createSteadyTimer(SteadyTimerOptions& ops) const;\n\n  /** \\brief Set an arbitrary XML/RPC value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param v The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const XmlRpc::XmlRpcValue& v) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::string& s) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const char* s) const;\n  /** \\brief Set a double value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param d The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, double d) const;\n  /** \\brief Set an integer value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param i The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, int i) const;\n  /** \\brief Set a boolean value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param b The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, bool b) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<std::string>& vec) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<double>& vec) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<float>& vec) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<int>& vec) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<bool>& vec) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, std::string>& map) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, double>& map) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, float>& map) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, int>& map) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a string vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get an int vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a boolean vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a double map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a float map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get an int map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a boolean map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server, with local caching\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a std::string vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get a int vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a bool vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string->std::string map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a string->double map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a string->float map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get a string->int map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a string->bool map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Check whether a parameter exists on the parameter server.\n   *\n   * \\param key The key to check.\n   *\n   * \\return true if the parameter exists, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool hasParam(const std::string& key) const;\n  /** \\brief Search up the tree for a parameter with a given key\n   *\n   * This function parameter server's searchParam feature to search up the tree for\n   * a parameter.  For example, if the parameter server has a parameter [/a/b]\n   * and you're in the namespace [/a/c/d], searching for the parameter \"b\" will\n   * yield [/a/b].  If [/a/c/d/b] existed, that parameter would be returned instead.\n   *\n   * \\param key the parameter to search for\n   * \\param [out] result the found value (if any)\n   *\n   * \\return true if the parameter was found, false otherwise.\n   */\n  bool searchParam(const std::string& key, std::string& result) const;\n  /** \\brief Delete a parameter from the parameter server.\n   *\n   * \\param key The key to delete.\n   *\n   * \\return true if the deletion succeeded, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool deleteParam(const std::string& key) const;\n\n  /** \\brief Get the keys for all the parameters in the parameter server.\n   * \\param keys The keys retrieved.\n   * \\return true if the query succeeded, false otherwise.\n   */\n  bool getParamNames(std::vector<std::string>& keys) const;\n\n  /** \\brief Assign value from parameter server, with default.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server, storing the result in param_val.  If the value\n   * cannot be retrieved from the server, default_val is used instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   * \\param[out] param_val Storage for the retrieved value.\n   * \\param default_val Value to use if the server doesn't contain this\n   * parameter.\n   * \\return true if the parameter was retrieved from the server, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<typename T>\n  bool param(const std::string& param_name, T& param_val, const T& default_val) const\n  {\n    if (hasParam(param_name))\n    {\n      if (getParam(param_name, param_val))\n      {\n        return true;\n      }\n    }\n\n    param_val = default_val;\n    return false;\n  }\n\n  /**\n   * \\brief Return value from parameter server, or default if unavailable.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server. If the parameter cannot be retrieved, \\c default_val\n   * is returned instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   *\n   * \\param default_val Value to return if the server doesn't contain this\n   * parameter.\n   *\n   * \\return The parameter value retrieved from the parameter server, or\n   * \\c default_val if unavailable.\n   *\n   * \\throws InvalidNameException If the parameter key begins with a tilde,\n   * or is an otherwise invalid graph resource name.\n   */\n  template<typename T>\n  T param(const std::string& param_name, const T& default_val) const\n  {\n      T param_val;\n      param(param_name, param_val, default_val);\n      return param_val;\n  }\n\n  /**\n   * \\brief Shutdown every handle created through this NodeHandle.\n   *\n   * This method will unadvertise every topic and service advertisement,\n   * and unsubscribe every subscription created through this NodeHandle.\n   */\n  void shutdown();\n\n  /** \\brief Check whether it's time to exit.\n   *\n   * This method checks to see if both ros::ok() is true and shutdown() has not been called on this NodeHandle, to see whether it's yet time\n   * to exit.  ok() is false once either ros::shutdown() or NodeHandle::shutdown() have been called\n   *\n   * \\return true if we're still OK, false if it's time to exit\n   */\n  bool ok() const;\n\nprivate:\n  struct no_validate { };\n  // this is pretty awful, but required to preserve public interface (and make minimum possible changes)\n  std::string resolveName(const std::string& name, bool remap, no_validate) const;\n\n  void construct(const std::string& ns, bool validate_name);\n  void destruct();\n\n  void initRemappings(const M_string& remappings);\n\n  std::string remapName(const std::string& name) const;\n\n  std::string namespace_;\n  std::string unresolved_namespace_;\n  M_string remappings_;\n  M_string unresolved_remappings_;\n\n  CallbackQueueInterface* callback_queue_;\n\n  NodeHandleBackingCollection* collection_;\n\n  bool ok_;\n};\n\n}\n\n#endif // ROSCPP_NODE_HANDLE_H\n","     MyClass my_class;","     ros::Publisher pub = handle.advertise<std_msgs::Empty>(\"my_topic\", 1, ","                                                            boost::bind(&MyClass::connectCallback, my_class, _1));"]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"topic","direction":null,"children":[{"type":"text","text":" Topic to advertise on"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"queue_size","direction":null,"children":[{"type":"text","text":" Maximum number of outgoing messages to be queued for delivery to subscribers"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"connect_cb","direction":null,"children":[{"type":"text","text":" Function to call when a subscriber connects"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":3,"parameter":"disconnect_cb","direction":null,"children":[{"type":"text","text":" (optional) Function to call when a subscriber disconnects"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":4,"parameter":"tracked_object","direction":null,"children":[{"type":"text","text":" (optional) A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,"},{"type":"text","text":" and if the reference count goes to 0 the subscriber callbacks will not get called."},{"type":"text","text":" Note that setting this will cause a new reference to be added to the object before the"},{"type":"text","text":" callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore"},{"type":"text","text":" thread) that the callback is invoked from."},{"type":"text","text":" "}]},{"type":"paramcommand","index":5,"parameter":"latch","direction":null,"children":[{"type":"text","text":" (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" On success, a Publisher that, when it goes out of scope, will automatically release a reference"},{"type":"text","text":" on this advertisement.  On failure, an empty Publisher which can be checked with:"}]},{"type":"verbatimcommand","parts":["ros::NodeHandle nodeHandle;","ros::publisher pub = nodeHandle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)callback);","if (pub)  // Enter if publisher is valid","{","...","}"]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::Publisher","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-Publisher","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.unresolved_remappings_":{"type":"variable","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.unresolved_remappings_","display_name":"unresolved_remappings_","ty":{"kind":"typedef","display_name":"ros::M_string","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"comment":null,"visibility":"default","accessibility":"private"},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-CallbackQueueInterface":{"type":"class","is_struct":false,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-CallbackQueueInterface","display_name":"CallbackQueueInterface","comment":null,"template_args":null,"children":[]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-advertise":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-advertise","display_name":"advertise","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Advertise a topic, with full range of AdvertiseOptions"}]},{"type":"paragraph","children":[{"type":"text","text":" This call connects to the master to publicize that the node will be"},{"type":"text","text":" publishing messages on the given topic.  This method returns a Publisher that allows you to"},{"type":"text","text":" publish a message on this topic."}]},{"type":"paragraph","children":[{"type":"text","text":" This is an advanced version advertise() that exposes all options (through the AdvertiseOptions structure)"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"ops","direction":null,"children":[{"type":"text","text":" Advertise options to use"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" On success, a Publisher that, when it goes out of scope, will automatically release a reference"},{"type":"text","text":" on this advertisement.  On failure, an empty Publisher which can be checked with:"}]},{"type":"verbatimcommand","parts":["ros::NodeHandle nodeHandle;","ros::AdvertiseOptions ops;","...","ros::publisher pub = nodeHandle.advertise(ops);","if (pub)  // Enter if publisher is valid","{","...","}"]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"ops","ty":{"kind":"lvaluereference","display_name":"ros::AdvertiseOptions &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::AdvertiseOptions","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseOptions","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"record","display_name":"ros::Publisher","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-Publisher","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParam":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParam","display_name":"getParam","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Get a boolean map value from the parameter server."}]},{"type":"paragraph","children":[{"type":"text","text":" If you want to provide a default value in case the key does not exist use param()."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"key","direction":null,"children":[{"type":"text","text":" The key to be used in the parameter server's dictionary"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"map","direction":"out","children":[{"type":"text","text":" Storage for the retrieved value."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" true if the parameter value was retrieved, false otherwise"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"key","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}},{"name":"map","ty":{"kind":"lvaluereference","display_name":"std::map<std::string, bool> &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"std::map<std::string, bool>","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"unexposed","display_name":"map<std::string, bool>","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-setParam":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-setParam","display_name":"setParam","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Set a bool vector value on the parameter server."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"key","direction":null,"children":[{"type":"text","text":" The key to be used in the parameter server's dictionary"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"map","direction":null,"children":[{"type":"text","text":" The value to be inserted."},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"key","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}},{"name":"map","ty":{"kind":"lvaluereference","display_name":"const std::map<std::string, bool> &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::map<std::string, bool>","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"unexposed","display_name":"map<std::string, bool>","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions","display_name":"ServiceClientOptions","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Encapsulates all options available for creating a ServiceClient"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions.header","root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions.init","root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions.service","root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions.ServiceClientOptions","root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions.md5sum","root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions.persistent"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createSteadyTimer":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createSteadyTimer","display_name":"createSteadyTimer","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a timer which will call a callback at the specified rate, using wall time to determine"},{"type":"text","text":" when to call the callback instead of ROS time.  This variant takes"},{"type":"text","text":" a class member function, and a shared pointer to the object to call the method on."}]},{"type":"paragraph","children":[{"type":"text","text":" When the Timer (and all copies of it) returned goes out of scope, the timer will automatically"},{"type":"text","text":" be stopped, and the callback will no longer be called."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"period","direction":null,"children":[{"type":"text","text":" The period at which to call the callback"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"callback","direction":null,"children":[{"type":"text","text":" The method to call"},{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"obj","direction":null,"children":[{"type":"text","text":" The object to call the method on.  Since this is a shared pointer, the object will"},{"type":"text","text":" automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of"},{"type":"text","text":" scope the callback will no longer be called (and therefore will not crash)."},{"type":"text","text":" "}]},{"type":"paramcommand","index":3,"parameter":"oneshot","direction":null,"children":[{"type":"text","text":" If true, this timer will only fire once"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::SteadyTimer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-SteadyTimer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-searchParam":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-searchParam","display_name":"searchParam","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Search up the tree for a parameter with a given key"}]},{"type":"paragraph","children":[{"type":"text","text":" This function parameter server's searchParam feature to search up the tree for"},{"type":"text","text":" a parameter.  For example, if the parameter server has a parameter [/a/b]"},{"type":"text","text":" and you're in the namespace [/a/c/d], searching for the parameter \"b\" will"},{"type":"text","text":" yield [/a/b].  If [/a/c/d/b] existed, that parameter would be returned instead."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"key","direction":null,"children":[{"type":"text","text":" the parameter to search for"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"result","direction":"out","children":[{"type":"text","text":" the found value (if any)"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" true if the parameter was found, false otherwise."}]}],"template_args":null,"params":[{"name":"key","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}},{"name":"result","ty":{"kind":"lvaluereference","display_name":"std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.collection_":{"type":"variable","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.collection_","display_name":"collection_","ty":{"kind":"pointer","display_name":"ros::NodeHandleBackingCollection *","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::NodeHandleBackingCollection","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandleBackingCollection","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null},"comment":null,"visibility":"default","accessibility":"private"},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-hasParam":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-hasParam","display_name":"hasParam","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Check whether a parameter exists on the parameter server."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"key","direction":null,"children":[{"type":"text","text":" The key to check."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" true if the parameter exists, false otherwise"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"key","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createTimer":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.createTimer","display_name":"createTimer","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a timer which will call a callback at the specified rate.  This variant takes"},{"type":"text","text":" a class member function, and a shared pointer to the object to call the method on."}]},{"type":"paragraph","children":[{"type":"text","text":" When the Timer (and all copies of it) returned goes out of scope, the timer will automatically"},{"type":"text","text":" be stopped, and the callback will no longer be called."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"period","direction":null,"children":[{"type":"text","text":" The period at which to call the callback"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"callback","direction":null,"children":[{"type":"text","text":" The method to call"},{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"obj","direction":null,"children":[{"type":"text","text":" The object to call the method on.  Since this is a shared pointer, the object will"},{"type":"text","text":" automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of"},{"type":"text","text":" scope the callback will no longer be called (and therefore will not crash)."},{"type":"text","text":" "}]},{"type":"paramcommand","index":3,"parameter":"oneshot","direction":null,"children":[{"type":"text","text":" If true, this timer will only fire once"},{"type":"text","text":" "}]},{"type":"paramcommand","index":4,"parameter":"autostart","direction":null,"children":[{"type":"text","text":" If true (default), return timer that is already started"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::Timer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-Timer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions","display_name":"SubscribeOptions","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Encapsulates all options available for creating a Subscriber"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.initByFullCallbackType","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.callback_queue","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.tracked_object","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.transport_hints","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.init","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.allow_concurrent_callbacks","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.datatype","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.create","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.queue_size","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.SubscribeOptions","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.md5sum","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.helper","root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions.topic"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-shutdown":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-shutdown","display_name":"shutdown","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Shutdown every handle created through this NodeHandle."}]},{"type":"paragraph","children":[{"type":"text","text":" This method will unadvertise every topic and service advertisement,"},{"type":"text","text":" and unsubscribe every subscription created through this NodeHandle."}]}],"template_args":null,"params":[],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-operator=":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-operator=","display_name":"operator=","comment":null,"template_args":null,"params":[{"name":"rhs","ty":{"kind":"lvaluereference","display_name":"const ros::NodeHandle &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"const ros::NodeHandle","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle","const_qualified":true,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"lvaluereference","display_name":"ros::NodeHandle &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::NodeHandle","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createTimer":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createTimer","display_name":"createTimer","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a timer which will call a callback at the specified rate.  This variant allows"},{"type":"text","text":" the full range of TimerOptions."}]},{"type":"paragraph","children":[{"type":"text","text":" When the Timer (and all copies of it) returned goes out of scope, the timer will automatically"},{"type":"text","text":" be stopped, and the callback will no longer be called."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"ops","direction":null,"children":[{"type":"text","text":" The options to use when creating the timer"}]}],"template_args":null,"params":[{"name":"ops","ty":{"kind":"lvaluereference","display_name":"ros::TimerOptions &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::TimerOptions","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"record","display_name":"ros::Timer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-Timer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.subscribe":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.subscribe","display_name":"subscribe","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Subscribe to a topic, version for arbitrary boost::function object"}]},{"type":"paragraph","children":[{"type":"text","text":" This method connects to the master to register interest in a given"},{"type":"text","text":" topic.  The node will automatically be connected with publishers on"},{"type":"text","text":" this topic.  On each message receipt, callback is invoked and passed a shared pointer"},{"type":"text","text":" to the message received.  This message should "},{"type":"inlinecommand","command":"b","arguments":["not"],"style":"bold"},{"type":"text","text":" be changed in place, as it"},{"type":"text","text":" is shared with any other subscriptions to this topic."}]},{"type":"paragraph","children":[{"type":"text","text":" This version of subscribe allows anything bindable to a boost::function object"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":null,"parameter":"M","direction":null,"children":[{"type":"text","text":" [template] the message type"},{"type":"text","text":" "}]},{"type":"paramcommand","index":null,"parameter":"C","direction":null,"children":[{"type":"text","text":" [template] the callback parameter type (e.g. const boost::shared_ptr"},{"type":"text","text":"<M"},{"type":"text","text":" const>"},{"type":"text","text":"&"},{"type":"text","text":" or const M"},{"type":"text","text":"&"},{"type":"text","text":")"},{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"topic","direction":null,"children":[{"type":"text","text":" Topic to subscribe to"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"queue_size","direction":null,"children":[{"type":"text","text":" Number of incoming messages to queue up for"},{"type":"text","text":" processing (messages in excess of this queue capacity will be"},{"type":"text","text":" discarded)."},{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"callback","direction":null,"children":[{"type":"text","text":" Callback to call when a message has arrived"},{"type":"text","text":" "}]},{"type":"paramcommand","index":3,"parameter":"tracked_object","direction":null,"children":[{"type":"text","text":" A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,"},{"type":"text","text":" and if the reference count goes to 0 the subscriber callbacks will not get called."},{"type":"text","text":" Note that setting this will cause a new reference to be added to the object before the"},{"type":"text","text":" callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore"},{"type":"text","text":" thread) that the callback is invoked from."},{"type":"text","text":" "}]},{"type":"paramcommand","index":4,"parameter":"transport_hints","direction":null,"children":[{"type":"text","text":" a TransportHints structure which defines various transport-related options"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic."},{"type":"text","text":" On failure, an empty Subscriber which can be checked with:"}]},{"type":"verbatimcommand","parts":["void callback(const std_msgs::Empty::ConstPtr& message){...}","ros::NodeHandle nodeHandle;","ros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);","if (sub)  // Enter if subscriber is valid","{","...","}"]},{"type":"paragraph","children":[{"type":"text","text":"  "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name"},{"type":"text","text":"  "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::Subscriber","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-Subscriber","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-initRemappings":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-initRemappings","display_name":"initRemappings","comment":null,"template_args":null,"params":[{"name":"remappings","ty":{"kind":"lvaluereference","display_name":"const ros::M_string &","name":null,"const_qualified":false,"pointee":{"kind":"typedef","display_name":"const ros::M_string","name":null,"const_qualified":true,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"private","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions","display_name":"AdvertiseServiceOptions","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Encapsulates all options available for creating a ServiceServer"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.datatype","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.md5sum","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.create","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.req_datatype","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.helper","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.init","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.AdvertiseServiceOptions","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.service","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.res_datatype","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.tracked_object","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.callback_queue","root/home/packages/astra_ros/astra_ros_api/n-ros.s-AdvertiseServiceOptions.initBySpecType"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.namespace_":{"type":"variable","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.namespace_","display_name":"namespace_","ty":{"kind":"elaborated","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"comment":null,"visibility":"default","accessibility":"private"},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-deleteParam":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-deleteParam","display_name":"deleteParam","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Delete a parameter from the parameter server."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"key","direction":null,"children":[{"type":"text","text":" The key to delete."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" true if the deletion succeeded, false otherwise."},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"key","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions","display_name":"TimerOptions","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Encapsulates all options available for starting a timer"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions.callback_queue","root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions.callback","root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions.tracked_object","root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions.period","root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions.TimerOptions","root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions.oneshot","root/home/packages/astra_ros/astra_ros_api/n-ros.s-TimerOptions.autostart"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions":{"type":"class","is_struct":true,"name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions","display_name":"WallTimerOptions","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Encapsulates all options available for starting a timer"}]}],"template_args":null,"children":["root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions.oneshot","root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions.callback","root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions.callback_queue","root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions.WallTimerOptions","root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions.period","root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions.tracked_object","root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions.autostart"]},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.U126NodeHandle":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.U126NodeHandle","display_name":"~NodeHandle","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Destructor"}]},{"type":"paragraph","children":[{"type":"text","text":" When a NodeHandle is destroyed, it decrements a global reference"},{"type":"text","text":" count by 1, and if the reference count is now 0, shuts down the"},{"type":"text","text":" node."}]}],"template_args":null,"params":[],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":true},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getNamespace":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getNamespace","display_name":"getNamespace","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Returns the namespace associated with this NodeHandle"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createWallTimer":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-createWallTimer","display_name":"createWallTimer","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a timer which will call a callback at the specified rate, using wall time to determine"},{"type":"text","text":" when to call the callback instead of ROS time.  This variant allows"},{"type":"text","text":" the full range of TimerOptions."}]},{"type":"paragraph","children":[{"type":"text","text":" When the Timer (and all copies of it) returned goes out of scope, the timer will automatically"},{"type":"text","text":" be stopped, and the callback will no longer be called."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"ops","direction":null,"children":[{"type":"text","text":" The options to use when creating the timer"}]}],"template_args":null,"params":[{"name":"ops","ty":{"kind":"lvaluereference","display_name":"ros::WallTimerOptions &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::WallTimerOptions","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-WallTimerOptions","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"record","display_name":"ros::WallTimer","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-WallTimer","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.serviceClient":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.serviceClient","display_name":"serviceClient","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a client for a service, version templated on service type"}]},{"type":"paragraph","children":[{"type":"text","text":" When the last handle reference of a persistent connection is cleared, the connection will automatically close."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"service_name","direction":null,"children":[{"type":"text","text":" The name of the service to connect to"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"persistent","direction":null,"children":[{"type":"text","text":" Whether this connection should persist.  Persistent services keep the connection to the remote host active"},{"type":"text","text":"        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as"},{"type":"text","text":"        robust to node failure as non-persistent services."},{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"header_values","direction":null,"children":[{"type":"text","text":" Key/value pairs you'd like to send along in the connection handshake"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::ServiceClient","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-ServiceClient","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParamCached":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-getParamCached","display_name":"getParamCached","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Get a string->bool map value from the parameter server, with local caching"}]},{"type":"paragraph","children":[{"type":"text","text":" This method will cache parameters locally, and subscribe for updates from"},{"type":"text","text":" the parameter server.  Once the parameter is retrieved for the first time"},{"type":"text","text":" no subsequent getCached() calls with the same key will query the master --"},{"type":"text","text":" they will instead look up in the local cache."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"key","direction":null,"children":[{"type":"text","text":" The key to be used in the parameter server's dictionary"},{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"map","direction":"out","children":[{"type":"text","text":" Storage for the retrieved value."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" true if the parameter value was retrieved, false otherwise"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"key","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}},{"name":"map","ty":{"kind":"lvaluereference","display_name":"std::map<std::string, bool> &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"std::map<std::string, bool>","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"unexposed","display_name":"map<std::string, bool>","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-construct":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-construct","display_name":"construct","comment":null,"template_args":null,"params":[{"name":"ns","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}},{"name":"validate_name","ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null}}],"ret_ty":{"kind":"void","display_name":"void","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"private","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-ok":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-ok","display_name":"ok","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Check whether it's time to exit."}]},{"type":"paragraph","children":[{"type":"text","text":" This method checks to see if both ros::ok() is true and shutdown() has not been called on this NodeHandle, to see whether it's yet time"},{"type":"text","text":" to exit.  ok() is false once either ros::shutdown() or NodeHandle::shutdown() have been called"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" true if we're still OK, false if it's time to exit"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"bool","display_name":"bool","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-serviceClient":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-serviceClient","display_name":"serviceClient","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Create a client for a service, version with full range of ServiceClientOptions"}]},{"type":"paragraph","children":[{"type":"text","text":" When the last handle reference of a persistent connection is cleared, the connection will automatically close."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"ops","direction":null,"children":[{"type":"text","text":" The options for this service client"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[{"name":"ops","ty":{"kind":"lvaluereference","display_name":"ros::ServiceClientOptions &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::ServiceClientOptions","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-ServiceClientOptions","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"record","display_name":"ros::ServiceClient","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-ServiceClient","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.param":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.param","display_name":"param","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Return value from parameter server, or default if unavailable."}]},{"type":"paragraph","children":[{"type":"text","text":" This method tries to retrieve the indicated parameter value from the"},{"type":"text","text":" parameter server. If the parameter cannot be retrieved, "},{"type":"inlinecommand","command":"c","arguments":["default_val"],"style":"monospace"},{"type":"text","text":" is returned instead."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"param_name","direction":null,"children":[{"type":"text","text":" The key to be searched on the parameter server."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"default_val","direction":null,"children":[{"type":"text","text":" Value to return if the server doesn't contain this"},{"type":"text","text":" parameter."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" The parameter value retrieved from the parameter server, or"},{"type":"text","text":" "},{"type":"inlinecommand","command":"c","arguments":["default_val"],"style":"monospace"},{"type":"text","text":" if unavailable."}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the parameter key begins with a tilde,"},{"type":"text","text":" or is an otherwise invalid graph resource name."}]}],"template_args":null,"params":[],"ret_ty":{"kind":"unexposed","display_name":"T","name":null,"const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-subscribe":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-subscribe","display_name":"subscribe","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Subscribe to a topic, version with full range of SubscribeOptions"}]},{"type":"paragraph","children":[{"type":"text","text":" This method connects to the master to register interest in a given"},{"type":"text","text":" topic.  The node will automatically be connected with publishers on"},{"type":"text","text":" this topic.  On each message receipt, fp is invoked and passed a shared pointer"},{"type":"text","text":" to the message received.  This message should "},{"type":"inlinecommand","command":"b","arguments":["not"],"style":"bold"},{"type":"text","text":" be changed in place, as it"},{"type":"text","text":" is shared with any other subscriptions to this topic."}]},{"type":"paragraph","children":[{"type":"text","text":" This version of subscribe allows the full range of options, exposed through the SubscribeOptions class"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"ops","direction":null,"children":[{"type":"text","text":" Subscribe options"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic."},{"type":"text","text":" On failure, an empty Subscriber which can be checked with:"}]},{"type":"verbatimcommand","parts":["SubscribeOptions ops;","...","ros::NodeHandle nodeHandle;","ros::Subscriber sub = nodeHandle.subscribe(ops);","if (sub)  // Enter if subscriber is valid","{","...","}"]},{"type":"paragraph","children":[{"type":"text","text":"  "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name"},{"type":"text","text":"  "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype"}]}],"template_args":null,"params":[{"name":"ops","ty":{"kind":"lvaluereference","display_name":"ros::SubscribeOptions &","name":null,"const_qualified":false,"pointee":{"kind":"record","display_name":"ros::SubscribeOptions","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.s-SubscribeOptions","const_qualified":false,"pointee":null,"elaborated":null},"elaborated":null}}],"ret_ty":{"kind":"record","display_name":"ros::Subscriber","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-Subscriber","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false},"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-remapName":{"type":"function","name":"root/home/packages/astra_ros/astra_ros_api/n-ros.c-NodeHandle.m-remapName","display_name":"remapName","comment":null,"template_args":null,"params":[{"name":"name","ty":{"kind":"lvaluereference","display_name":"const std::string &","name":null,"const_qualified":false,"pointee":{"kind":"elaborated","display_name":"const std::string","name":null,"const_qualified":true,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"elaborated":null}}],"ret_ty":{"kind":"elaborated","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":{"kind":"typedef","display_name":"std::string","name":null,"const_qualified":false,"pointee":null,"elaborated":null}},"visibility":"default","accessibility":"private","is_ctor":false,"is_dtor":false}}}